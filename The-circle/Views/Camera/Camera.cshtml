@{
Layout = null;
var certBase64 = ViewBag.CertBase64 as string ?? "";
var email      = ViewBag.Email      as string ?? "Onbekend";
}
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Camera Stream - @email</title>
    <link rel="stylesheet"
          href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" />
</head>
<body class="d-flex justify-content-center align-items-center vh-100 bg-dark text-light">
<div class="text-center">
    <h1>Camera Stream — @email</h1>

    <div class="mb-3">
        <label class="form-label">Upload Private Key (.pem)</label>
        <input type="file" id="privateKeyFile" accept=".pem" class="form-control" />
    </div>

    <video id="video" width="320" height="240" autoplay muted class="border"></video><br/>
    <button id="toggleBtn" class="btn btn-danger mt-3">Start Camera</button>
    <p id="status" class="mt-3"></p>
</div>

<script>
    const status = document.getElementById('status');
    const privateKeyInput = document.getElementById('privateKeyFile');
    const video = document.getElementById('video');
    const btn = document.getElementById('toggleBtn');

    let stream, privateKey, certBytes, chunkIndex = 0;
    const streamId = crypto.randomUUID();

    // 1) Decode cert injected by Razor (no whitespace/newlines)
    try {
        const cleanB64 = `@Html.Raw(certBase64)`.replace(/[\r\n\s]/g,'');
        const bin = atob(cleanB64);
        certBytes = new Uint8Array(bin.length);
        for (let i=0; i<bin.length; i++) certBytes[i] = bin.charCodeAt(i);
        status.textContent = "✅ Certificate loaded from session.";
    } catch(e) {
        console.error("Certificate decode error:", e);
        status.textContent = "❌ Failed to load certificate.";
    }

    // 2) Only private key upload
    privateKeyInput.addEventListener('change', async () => {
        const pem = await privateKeyInput.files[0].text();
        const b64 = pem.replace(/-----[^-]+-----/g,'').replace(/\s+/g,'');
        const bin = atob(b64);
        const buf = new Uint8Array(bin.length);
        for (let i=0; i<bin.length; i++) buf[i] = bin.charCodeAt(i);
        try {
            privateKey = await crypto.subtle.importKey(
                'pkcs8', buf.buffer,
                { name:'RSASSA-PKCS1-v1_5', hash:'SHA-256' },
                false, ['sign']
            );
            status.textContent = "✅ Private key loaded.";
        } catch(err) {
            console.error(err);
            status.textContent = "❌ Invalid private key.";
        }
    });

    // 3) Start/stop stream
    btn.onclick = async () => {
        if (!privateKey || !certBytes) {
            status.textContent = "❌ Upload private key & ensure cert loaded.";
            return;
        }
        if (!stream) {
            stream = await navigator.mediaDevices.getUserMedia({video:true});
            video.srcObject = stream;
            btn.textContent = "Stop Camera";
            sendFrames();
        } else {
            stream.getTracks().forEach(t=>t.stop());
            stream = null; video.srcObject=null;
            btn.textContent = "Start Camera";
        }
    };

    // 4) buildPayload & sendFrames (little-endian for all ints)
    function streamIdToBytes(guid) {
        const hex = guid.replace(/-/g,''), bytes = new Uint8Array(16);
        for (let i=0;i<16;i++) bytes[i] = parseInt(hex.substr(2*i,2),16);
        return bytes;
    }

    function buildPayload(idBytes, idx, chunk, sig, cert) {
        const total = 16+4+4+chunk.length+2+sig.length+2+cert.length;
        const buf = new ArrayBuffer(total), view = new DataView(buf), u8 = new Uint8Array(buf);
        let o = 0;
        u8.set(idBytes, o); o+=16;
        view.setInt32(o, idx, true); o+=4;
        view.setInt32(o, chunk.length, true); o+=4;
        u8.set(chunk, o); o+=chunk.length;
        view.setUint16(o, sig.length, true); o+=2;
        u8.set(sig, o); o+=sig.length;
        view.setUint16(o, cert.length, true); o+=2;
        u8.set(cert, o);
        return buf;
    }

    function sendFrames() {
        const cap = new ImageCapture(stream.getVideoTracks()[0]), idBytes = streamIdToBytes(streamId);
        (async function loop() {
            const frm = await cap.grabFrame();
            const c = document.createElement('canvas');
            c.width=frm.width; c.height=frm.height;
            c.getContext('2d').drawImage(frm,0,0);
            c.toBlob(async blob=>{
                const chunk = new Uint8Array(await blob.arrayBuffer());
                const sig   = new Uint8Array(await crypto.subtle.sign(
                    {name:'RSASSA-PKCS1-v1_5'}, privateKey, chunk
                ));
                const payload = buildPayload(idBytes, chunkIndex++, chunk, sig, certBytes);
                await fetch('/api/videochunk',{
                    method:'POST',
                    headers:{
                        'Content-Type':'application/octet-stream',
                        'X-Stream-Id':streamId,
                        'X-Chunk-Index':chunkIndex-1
                    },
                    body:payload,
                    credentials:'include'
                });
            },'image/jpeg',0.5);
            if(stream) setTimeout(loop,100);
        })();
    }
</script>
</body>
</html>
